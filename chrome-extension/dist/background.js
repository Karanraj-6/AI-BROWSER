var N=Object.defineProperty;var b=(r,e,s)=>e in r?N(r,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[e]=s;var _=(r,e,s)=>b(r,typeof e!="symbol"?e+"":e,s);class x{sendContentAction(e,s){return new Promise((n,i)=>{if(typeof e!="number"){i(new Error("tab-id-required"));return}chrome.tabs.sendMessage(e,{type:"CONTENT_ACTION",payload:s},c=>{var t;const o=(t=chrome.runtime)==null?void 0:t.lastError;if(o){i(new Error(o.message));return}n(c)})})}async handleAction(e){try{switch(e.type){case"NAVIGATE":return typeof e.tabId=="number"?await chrome.tabs.update(e.tabId,{url:e.url}):await chrome.tabs.update({url:e.url}),{success:!0};case"CLICK":return await this.sendContentAction(e.tabId,{type:"CLICK",selector:e.selector});case"FILL":return await this.sendContentAction(e.tabId,{type:"FILL",selector:e.selector,value:e.value});case"EVALUATE_SCRIPT":return await this.sendContentAction(e.tabId,{type:"EVALUATE_SCRIPT",code:e.code});case"TAKE_SCREENSHOT":return{success:!0,dataUrl:await chrome.tabs.captureVisibleTab(e.windowId??void 0,{format:"png"})};default:return{success:!1,error:`unknown-action:${e.type}`}}}catch(s){return{success:!1,error:(s==null?void 0:s.message)||String(s)}}}}const P=2e3,k=3e4;class R{constructor(e){_(this,"url");_(this,"status","disconnected");_(this,"socket",null);_(this,"reconnectTimer");_(this,"nextId",1);_(this,"pending",new Map);_(this,"statusListeners",new Set);_(this,"notificationListeners",new Set);this.url=e,this.connect()}connect(){if(!(this.socket||this.status==="connecting")){this.clearReconnectTimer(),this.updateStatus("connecting");try{this.socket=new WebSocket(this.url)}catch(e){this.handleDisconnect(e);return}this.socket.addEventListener("open",()=>{this.updateStatus("connected")}),this.socket.addEventListener("message",e=>{this.handleMessage(e.data)}),this.socket.addEventListener("error",()=>{}),this.socket.addEventListener("close",()=>{this.handleDisconnect()})}}handleDisconnect(e){this.socket=null,this.updateStatus("disconnected");for(const[s,n]of this.pending.entries())n.reject(e??new Error("MCP bridge disconnected before response arrived.")),n.timeoutId!==void 0&&clearTimeout(n.timeoutId),this.pending.delete(s);this.scheduleReconnect()}scheduleReconnect(){this.reconnectTimer===void 0&&(this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=void 0,this.connect()},P))}clearReconnectTimer(){this.reconnectTimer!==void 0&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=void 0)}handleMessage(e){let s;try{s=JSON.parse(e)}catch{console.warn("Ignoring non-JSON message from MCP bridge",e);return}if(typeof(s==null?void 0:s.id)=="string"||typeof(s==null?void 0:s.id)=="number"){const n=String(s.id),i=this.pending.get(n);if(!i)return;if(this.pending.delete(n),i.timeoutId!==void 0&&clearTimeout(i.timeoutId),"error"in s&&s.error){const c=s.error.message??"Unknown MCP error";i.reject(new Error(c))}else"result"in s?i.resolve(s.result):i.resolve(void 0);return}for(const n of this.notificationListeners)try{n(s)}catch(i){console.error("MCP notification listener failed",i)}}updateStatus(e){if(this.status!==e){this.status=e;for(const s of this.statusListeners)try{s(e)}catch(n){console.error("MCP status listener failed",n)}}}onStatusChange(e){return this.statusListeners.add(e),e(this.status),()=>{this.statusListeners.delete(e)}}onNotification(e){return this.notificationListeners.add(e),()=>{this.notificationListeners.delete(e)}}getStatus(){return this.status}isConnected(){return this.status==="connected"}reconnectNow(){this.socket?this.socket.close():this.connect()}async callTool(e,s={}){if(!this.isConnected())throw new Error("mcp-disconnected");return this.sendRequest("tools/call",{name:e,arguments:s})}sendRequest(e,s){if(!this.socket||this.socket.readyState!==WebSocket.OPEN)throw new Error("mcp-disconnected");const n=String(this.nextId++),i={jsonrpc:"2.0",id:n,method:e,params:s};return new Promise((c,o)=>{var l;const t=setTimeout(()=>{this.pending.delete(n),o(new Error("mcp-timeout"))},k);this.pending.set(n,{resolve:c,reject:o,timeoutId:t});try{(l=this.socket)==null||l.send(JSON.stringify(i))}catch(p){this.pending.delete(n),clearTimeout(t),o(p)}})}}const T={GEMINI_KEY:"geminiKey",AUTO_MODE:"autoMode"},G="gemini-2.5-flash",U="ws://127.0.0.1:8080",E=new x,f=new R(U),S=r=>new Promise((e,s)=>{chrome.storage.local.get(r,n=>{var c;const i=(c=chrome.runtime)==null?void 0:c.lastError;if(i){s(new Error(i.message));return}e(n||{})})}),K=r=>new Promise((e,s)=>{chrome.storage.local.set(r,()=>{var i;const n=(i=chrome.runtime)==null?void 0:i.lastError;if(n){s(new Error(n.message));return}e()})}),y=(r,e)=>{chrome.runtime.sendMessage({type:r,payload:e})},C=async()=>{var e;const r=await chrome.tabs.query({active:!0,currentWindow:!0});return(e=r==null?void 0:r[0])==null?void 0:e.id},I=async()=>{const r=await chrome.tabs.query({active:!0,currentWindow:!0}),e=r==null?void 0:r[0];return e?{id:e.id,url:e.url??void 0,title:e.title??void 0}:null},O=async r=>{const e=await chrome.tabs.query({});if(!(e!=null&&e.length))return null;const s=["# list_pages response","## Pages"];return e.forEach((n,i)=>{const c=(n==null?void 0:n.url)??"about:blank",o=n!=null&&n.title?` (${n.title})`:"",t=!!(n!=null&&n.active)||typeof r=="number"&&(n==null?void 0:n.id)===r;s.push(`${i}: ${c}${o}${t?" [selected]":""}`)}),s.join(`
`)},$=(r,e,s,n,i)=>{const c=r.map(p=>({role:p.role==="assistant"?"model":"user",parts:[{text:p.content}]}));c.push({role:"user",parts:[{text:e}]});const o=n!=null&&n.url?`Active tab: ${n.title??"Untitled"} (${n.url}). Always begin automation by emitting CALL_TOOL extension_select_page with { "url": "${n.url}" } so the MCP operates on the existing tab.
`:`Always begin automation by selecting the current tab via CALL_TOOL extension_select_page before other actions.
`,t=s==="connected"?`${o}The model is authorized to call any tool exposed by the Chrome DevTools MCP server. Use exact tool identifiers when emitting CALL_TOOL (for example: list_pages, select_page, navigate_page, new_page, extension_click_selector, extension_fill_selector, extension_evaluate_script, etc.). Decide which tools to use based on the user's request and combine them as needed — you do not need to ask for permission before calling tools. Prefer operating inside the user's current Chrome window and navigate within the active tab when possible; open new tabs/pages only when necessary. Wait for navigations to complete before interacting and always select a page (select_page or extension_select_page) only after it is actually open. If an action is potentially destructive (closing pages, deleting data), proceed only if the user explicitly requested it.`:"The Chrome DevTools MCP bridge is currently unavailable. Do not emit CALL_TOOL steps.",l=i?`Current open tabs/windows (from list_pages):
${i}
Use these entries to decide whether navigation is required before selecting a page.
`:"";return{contents:c,systemInstruction:{parts:[{text:`You are an automation planner for a Chrome extension. Always respond with JSON matching this schema:
{
  "reply": string,
  "plan": [
    { "type": "NAVIGATE" | "CLICK" | "FILL" | "EVALUATE_SCRIPT" | "TAKE_SCREENSHOT" | "CALL_TOOL", "params": object }
  ]
}
Only include supported action types. Leave "plan" empty if no browser action is required. Prefer short, factual replies. `+t+l}]},generationConfig:{temperature:.3,responseMimeType:"application/json"}}},D=r=>{if(!r)return null;const s=r.trim().replace(/```json|```/g,"").trim();try{return JSON.parse(s)}catch{try{const i=s.indexOf("{"),c=s.lastIndexOf("}");if(i!==-1&&c!==-1&&c>i)return JSON.parse(s.slice(i,c+1))}catch{}}return null},q=async(r,e)=>{var a,h,w,d,A;const{[T.GEMINI_KEY]:s}=await S([T.GEMINI_KEY]);if(!s)throw new Error("missing-gemini-key");const n=await I(),i=await O(n==null?void 0:n.id),c=$(e,r,f.getStatus(),n,i),o=await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${G}:generateContent?key=${encodeURIComponent(s)}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)});if(!o.ok){const L=await o.text();throw new Error(`gemini-error:${o.status}:${L||o.statusText}`)}const t=await o.json(),l=((A=(d=(w=(h=(a=t==null?void 0:t.candidates)==null?void 0:a[0])==null?void 0:h.content)==null?void 0:w.parts)==null?void 0:d[0])==null?void 0:A.text)??"",p=D(l);return!p||typeof p.reply!="string"||!Array.isArray(p.plan)?{reply:l||"I was unable to create a plan.",plan:[]}:{reply:p.reply,plan:p.plan.filter(L=>L&&typeof L.type=="string")}},M=async(r,e)=>{var i;const s=[],n=await I();for(let c=0;c<r.length;c+=1){const o=r[c];y("LLM_PROGRESS",{status:"running",index:c,step:o});try{const t=o!=null&&o.params&&typeof o.params=="object"?o.params:{};let l;if(o.type==="CALL_TOOL"){let p=t.tool||t.toolName||t.tool_name||t.name||o.tool||o.toolName||o.tool_name,a;if(!p){let u=null,m={};if(t!=null&&t.selector?(t==null?void 0:t.value)!==void 0?(u="extension_fill_selector",m={selector:t.selector,value:t.value}):(u="extension_click_selector",m={selector:t.selector}):t!=null&&t.url?(u="navigate_page",m={type:"url",url:t.url}):t!=null&&t.code?(u="extension_evaluate_script",m={code:t.code}):t!=null&&t.text&&typeof t.text=="string"&&(u="extension_fill_selector",m={selector:t.selector??"input",value:t.text}),u)y("LLM_WARNING",{message:"CALL_TOOL missing tool name — inferring tool",inferredTool:u,originalStep:o}),p=u,a=m;else throw new Error("call-tool-missing-name")}const h=o,w=t;a||(a=t.arguments||t.tool_params||t.toolParams||t.args||o.arguments||o.args||o.tool_params||o.toolParams||{}),!a||Object.keys(a).length===0?(h.url&&(a={...a,url:h.url}),w.url&&(a={...a,url:w.url}),h.selector&&(a={...a,selector:h.selector}),h.value&&(a={...a,value:h.value}),h.code&&(a={...a,code:h.code}),h.tool_params&&typeof h.tool_params=="object"&&(a={...a,...h.tool_params}),w.tool_params&&typeof w.tool_params=="object"&&(a={...a,...w.tool_params})):(h.url&&(a.url=h.url),w.url&&(a.url=w.url));try{y("LLM_DEBUG",{message:"Resolved CALL_TOOL",index:c,step:o,toolName:p,toolArgs:a})}catch{}console.debug("[MCP DEBUG] CALL_TOOL resolved",{index:c,toolName:p,toolArgs:a,step:o});const d=String(p||"").toLowerCase(),A=d.startsWith("extension_"),L=d.startsWith("pages_")||d==="new_page"||d==="navigate_page"||d==="list_pages"||d==="select_page",g=u=>a&&a[u]!==void 0?a[u]:o[u]??t[u];if(L)if(d==="new_page"){const u=g("url"),m=!!g("forceNew")||!!g("force_new");if(!u)throw y("LLM_WARNING",{message:"Blocked request to open a new page without URL.",index:c,step:o}),new Error("blocked-new-page-without-url");if(m){if(!f.isConnected())throw y("LLM_WARNING",{message:"Attempted force-new but MCP bridge not connected; blocked.",index:c,step:o}),new Error("blocked-new-page-force-new-bridge-off");l=await f.callTool("new_page",a)}else l=await E.handleAction({type:"NAVIGATE",url:u,tabId:e})}else if(d==="navigate_page"||d==="pages_navigate"||d==="pages_navigate_page"){const u=g("url");if(!u)throw new Error("navigate-missing-url");l=await E.handleAction({type:"NAVIGATE",url:u,tabId:e})}else if(d==="list_pages")l={content:[{type:"text",text:await O(n==null?void 0:n.id)??`# list_pages response
## Pages
0: ${(n==null?void 0:n.url)??"about:blank"} [selected]`}]};else if(d==="select_page"||d==="extension_select_page"){const u=g("url")??g("pageUrl")??g("page");if(!u)throw new Error("select-page-missing-url");l=await E.handleAction({type:"NAVIGATE",url:u,tabId:e})}else{if(!f.isConnected())throw new Error("mcp-bridge-not-connected");l=await f.callTool(p,a)}else if(A)if(d.includes("click")&&g("selector"))l=await E.handleAction({type:"CLICK",selector:g("selector"),tabId:e});else if(d.includes("fill")&&g("selector"))l=await E.handleAction({type:"FILL",selector:g("selector"),value:g("value")??g("text")??g("v"),tabId:e});else if(d.includes("evaluate")&&g("code"))l=await E.handleAction({type:"EVALUATE_SCRIPT",code:g("code"),tabId:e});else if(d.includes("select_page")){const u=g("url")??g("pageUrl")??g("page");if(!u)throw new Error("select-page-missing-url");l=await E.handleAction({type:"NAVIGATE",url:u,tabId:e})}else{if(!f.isConnected())throw new Error("mcp-bridge-not-connected");l=await f.callTool(p,a)}else{if(!f.isConnected())throw new Error("mcp-bridge-not-connected");l=await f.callTool(p,a)}if(l&&(l.isError||l.success===!1)){const m=(Array.isArray(l.content)?(i=l.content.find(v=>v&&typeof v.text=="string"))==null?void 0:i.text:void 0)||l.error||l.message||"CALL_TOOL failed";throw new Error(m)}}else l=await E.handleAction({...t,type:o.type,tabId:e});s.push({success:!0,result:l}),y("LLM_PROGRESS",{status:"completed",index:c,step:o,result:l})}catch(t){s.push({success:!1,error:(t==null?void 0:t.message)??String(t)}),y("LLM_PROGRESS",{status:"failed",index:c,step:o,error:(t==null?void 0:t.message)??String(t)});break}}return s},V=async r=>{const{prompt:e,history:s=[],autoMode:n=!1,tabId:i}=r||{};if(!e||typeof e!="string")throw new Error("invalid-prompt");const c=typeof i=="number"?i:await C(),o=await q(e,s);y("LLM_PLAN",{plan:o.plan,reply:o.reply});let t;return n&&o.plan.length>0&&(t=await M(o.plan,c)),{success:!0,reply:o.reply,plan:o.plan,execution:t}},j=async r=>{const{plan:e=[],tabId:s}=r||{};if(!Array.isArray(e)||e.length===0)throw new Error("empty-plan");const n=typeof s=="number"?s:await C();return{success:!0,execution:await M(e,n)}},W=async r=>{const e={};return typeof(r==null?void 0:r.geminiKey)=="string"&&(e[T.GEMINI_KEY]=r.geminiKey.trim()),typeof(r==null?void 0:r.autoMode)=="boolean"&&(e[T.AUTO_MODE]=r.autoMode),Object.keys(e).length?(await K(e),{success:!0}):{success:!0}},F=async()=>{const r=await S([T.GEMINI_KEY,T.AUTO_MODE]);return{success:!0,geminiKey:(r==null?void 0:r[T.GEMINI_KEY])??null,autoMode:(r==null?void 0:r[T.AUTO_MODE])??!1,mcpStatus:f.getStatus()}},Y=async r=>{const{tool:e,toolName:s,name:n,arguments:i,params:c}=r||{},o=e||s||n||(c==null?void 0:c.tool),t=i??(c==null?void 0:c.arguments)??(r==null?void 0:r.args)??{};if(!o)throw new Error("tool-required");return{success:!0,result:await f.callTool(o,t)}};chrome.runtime.onMessage.addListener((r,e,s)=>{const{type:n,payload:i}=r||{};if(!n)return;const c=o=>{o.then(t=>s(t)).catch(t=>s({success:!1,error:(t==null?void 0:t.message)??String(t)}))};switch(n){case"MCP_ACTION":return c(E.handleAction(i)),!0;case"LLM_REQUEST":return c(V(i)),!0;case"EXECUTE_PLAN":return c(j(i)),!0;case"SAVE_SETTINGS":return c(W(i)),!0;case"GET_SETTINGS":return c(F()),!0;case"MCP_CALL_TOOL":return c(Y(i)),!0;default:s({success:!1,error:`unknown-message:${n}`});return}});f.onStatusChange(r=>{y("MCP_STATUS",{status:r})});f.onNotification(r=>{y("MCP_NOTIFICATION",r)});
