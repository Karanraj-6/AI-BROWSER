var k=Object.defineProperty;var x=(t,e,n)=>e in t?k(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var L=(t,e,n)=>x(t,typeof e!="symbol"?e+"":e,n);class G{async waitForTabLoad(e,n=2e4){if(typeof e!="number")return;const s=async()=>{await new Promise(o=>setTimeout(o,150))};try{const o=await chrome.tabs.get(e);if((o==null?void 0:o.status)==="complete"){await s();return}}catch{return}await new Promise((o,c)=>{const i=setTimeout(()=>{chrome.tabs.onUpdated.removeListener(r),c(new Error("navigation-timeout"))},n),r=(a,d)=>{a===e&&d.status==="complete"&&(clearTimeout(i),chrome.tabs.onUpdated.removeListener(r),s().then(o).catch(o))};chrome.tabs.onUpdated.addListener(r)})}sendContentAction(e,n){return new Promise((s,o)=>{if(typeof e!="number"){o(new Error("tab-id-required"));return}chrome.tabs.sendMessage(e,{type:"CONTENT_ACTION",payload:n},c=>{var r;const i=(r=chrome.runtime)==null?void 0:r.lastError;if(i){o(new Error(i.message));return}s(c)})})}async handleAction(e){try{switch(e.type){case"NAVIGATE":{const n=typeof e.tabId=="number"?await chrome.tabs.update(e.tabId,{url:e.url}):await chrome.tabs.update({url:e.url}),s=typeof e.tabId=="number"?e.tabId:n==null?void 0:n.id;try{await this.waitForTabLoad(s)}catch(o){console.warn("Timed out waiting for navigation",o)}return{success:!0}}case"CLICK":return await this.waitForTabLoad(e.tabId),await this.sendContentAction(e.tabId,{type:"CLICK",selector:e.selector});case"FILL":return await this.waitForTabLoad(e.tabId),await this.sendContentAction(e.tabId,{type:"FILL",selector:e.selector,value:e.value});case"EVALUATE_SCRIPT":return await this.waitForTabLoad(e.tabId),await this.sendContentAction(e.tabId,{type:"EVALUATE_SCRIPT",code:e.code});case"TAKE_SCREENSHOT":return{success:!0,dataUrl:await chrome.tabs.captureVisibleTab(e.windowId??void 0,{format:"png"})};default:return{success:!1,error:`unknown-action:${e.type}`}}}catch(n){return{success:!1,error:(n==null?void 0:n.message)||String(n)}}}}const $=2e3,K=3e4,F=t=>{if(typeof t!="string")return null;const e=t.trim();return e.length?e:null};class q{constructor(e){L(this,"url",null);L(this,"status","disconnected");L(this,"socket",null);L(this,"reconnectTimer");L(this,"nextId",1);L(this,"pending",new Map);L(this,"statusListeners",new Set);L(this,"notificationListeners",new Set);e&&this.setUrl(e)}setUrl(e){const n=F(e);if(this.url===n){n&&!this.socket&&this.connect(),n||this.teardown(new Error("MCP bridge disabled by configuration."),{suppressReconnect:!0});return}if(this.url=n,!this.url){this.teardown(new Error("MCP bridge disabled by configuration."),{suppressReconnect:!0});return}this.teardown(new Error("Reconfiguring MCP bridge endpoint."),{suppressReconnect:!0}),this.connect()}getUrl(){return this.url}connect(){if(!this.url){this.updateStatus("disconnected");return}if(!(this.socket||this.status==="connecting")){this.clearReconnectTimer(),this.updateStatus("connecting");try{this.socket=new WebSocket(this.url)}catch(e){this.teardown(e);return}this.socket.addEventListener("open",()=>{this.updateStatus("connected")}),this.socket.addEventListener("message",e=>{this.handleMessage(e.data)}),this.socket.addEventListener("error",()=>{}),this.socket.addEventListener("close",()=>{this.teardown()})}}teardown(e,n={}){if(this.socket)try{this.socket.close()}catch{}this.socket=null,this.updateStatus("disconnected");for(const[s,o]of this.pending.entries())o.reject(e??new Error("MCP bridge disconnected before response arrived.")),o.timeoutId!==void 0&&clearTimeout(o.timeoutId),this.pending.delete(s);if(n.suppressReconnect||!this.url){this.clearReconnectTimer();return}this.scheduleReconnect()}scheduleReconnect(){this.reconnectTimer!==void 0||!this.url||(this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=void 0,this.connect()},$))}clearReconnectTimer(){this.reconnectTimer!==void 0&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=void 0)}handleMessage(e){let n;try{n=JSON.parse(e)}catch{console.warn("Ignoring non-JSON message from MCP bridge",e);return}if(typeof(n==null?void 0:n.id)=="string"||typeof(n==null?void 0:n.id)=="number"){const s=String(n.id),o=this.pending.get(s);if(!o)return;if(this.pending.delete(s),o.timeoutId!==void 0&&clearTimeout(o.timeoutId),"error"in n&&n.error){const c=n.error.message??"Unknown MCP error";o.reject(new Error(c))}else"result"in n?o.resolve(n.result):o.resolve(void 0);return}for(const s of this.notificationListeners)try{s(n)}catch(o){console.error("MCP notification listener failed",o)}}updateStatus(e){if(this.status!==e){this.status=e;for(const n of this.statusListeners)try{n(e)}catch(s){console.error("MCP status listener failed",s)}}}onStatusChange(e){return this.statusListeners.add(e),e(this.status),()=>{this.statusListeners.delete(e)}}onNotification(e){return this.notificationListeners.add(e),()=>{this.notificationListeners.delete(e)}}getStatus(){return this.status}isConnected(){return this.status==="connected"}reconnectNow(){if(!this.url){this.updateStatus("disconnected");return}this.socket?this.socket.close():this.connect()}async callTool(e,n={}){if(!this.isConnected())throw new Error("mcp-disconnected");return this.sendRequest("tools/call",{name:e,arguments:n})}sendRequest(e,n){if(!this.socket||this.socket.readyState!==WebSocket.OPEN)throw new Error("mcp-disconnected");const s=String(this.nextId++),o={jsonrpc:"2.0",id:s,method:e,params:n};return new Promise((c,i)=>{var a;const r=setTimeout(()=>{this.pending.delete(s),i(new Error("mcp-timeout"))},K);this.pending.set(s,{resolve:c,reject:i,timeoutId:r});try{(a=this.socket)==null||a.send(JSON.stringify(o))}catch(d){this.pending.delete(s),clearTimeout(r),i(d)}})}}const w={GEMINI_KEY:"geminiKey",AUTO_MODE:"autoMode",MCP_URL:"mcpUrl"},V="gemini-2.5-flash",T=new G,p=new q,v=t=>new Promise((e,n)=>{chrome.storage.local.get(t,s=>{var c;const o=(c=chrome.runtime)==null?void 0:c.lastError;if(o){n(new Error(o.message));return}e(s||{})})}),j=t=>new Promise((e,n)=>{chrome.storage.local.set(t,()=>{var o;const s=(o=chrome.runtime)==null?void 0:o.lastError;if(s){n(new Error(s.message));return}e()})}),D=t=>new Promise((e,n)=>{chrome.storage.local.remove(t,()=>{var o;const s=(o=chrome.runtime)==null?void 0:o.lastError;if(s){n(new Error(s.message));return}e()})});v([w.MCP_URL]).then(t=>{const e=typeof(t==null?void 0:t[w.MCP_URL])=="string"?t[w.MCP_URL].trim():"";e&&p.setUrl(e)}).catch(t=>{console.warn("Failed to restore MCP URL from storage",t)});const E=(t,e)=>{chrome.runtime.sendMessage({type:t,payload:e})},U=async()=>{var e;const t=await chrome.tabs.query({active:!0,currentWindow:!0});return(e=t==null?void 0:t[0])==null?void 0:e.id},C=async()=>{const t=await chrome.tabs.query({active:!0,currentWindow:!0}),e=t==null?void 0:t[0];return e?{id:e.id,url:e.url??void 0,title:e.title??void 0}:null},P=async t=>{const e=await chrome.tabs.query({});if(!(e!=null&&e.length))return null;const n=["# list_pages response","## Pages"];return e.forEach((s,o)=>{const c=(s==null?void 0:s.url)??"about:blank",i=s!=null&&s.title?` (${s.title})`:"",r=!!(s!=null&&s.active)||typeof t=="number"&&(s==null?void 0:s.id)===t;n.push(`${o}: ${c}${i}${r?" [selected]":""}`)}),n.join(`
`)},b=t=>{try{const e=new URL(t,t.startsWith("http")?void 0:"https://placeholder.local");e.hash="";const n=e.pathname.endsWith("/")&&e.pathname!=="/"?e.pathname.slice(0,-1):e.pathname;return`${e.protocol}//${e.host}${n}${e.search}`}catch{return t}},N=(t,e)=>!t||!e?!1:b(t)===b(e),W=(t,e,n,s,o)=>{const c=t.map(d=>({role:d.role==="assistant"?"model":"user",parts:[{text:d.content}]}));c.push({role:"user",parts:[{text:e}]});const i=s!=null&&s.url?`Active tab: ${s.title??"Untitled"} (${s.url}). Always begin automation by emitting CALL_TOOL extension_select_page with { "url": "${s.url}" } so the MCP operates on the existing tab.
`:`Always begin automation by selecting the current tab via CALL_TOOL extension_select_page before other actions.
`,r=n==="connected"?`${i}The model is authorized to call any tool exposed by the Chrome DevTools MCP server. Use exact tool identifiers when emitting CALL_TOOL (for example: list_pages, select_page, navigate_page, new_page, extension_click_selector, extension_fill_selector, extension_evaluate_script, etc.). Decide which tools to use based on the user's request and combine them as needed — you do not need to ask for permission before calling tools. Prefer operating inside the user's current Chrome window and navigate within the active tab when possible; open new tabs/pages only when necessary. Wait for navigations to complete before interacting and always select a page (select_page or extension_select_page) only after it is actually open. If an action is potentially destructive (closing pages, deleting data), proceed only if the user explicitly requested it.`:"The hosted Chrome DevTools MCP bridge is currently unavailable or not configured. Do not emit CALL_TOOL steps until the connection is restored.",a=o?`Current open tabs/windows (from list_pages):
${o}
Use these entries to decide whether navigation is required before selecting a page.
`:"";return{contents:c,systemInstruction:{parts:[{text:`You are an automation planner for a Chrome extension. Always respond with JSON matching this schema:
{
  "reply": string,
  "plan": [
    { "type": "NAVIGATE" | "CLICK" | "FILL" | "EVALUATE_SCRIPT" | "TAKE_SCREENSHOT" | "CALL_TOOL", "params": object }
  ]
}
Only include supported action types. Leave "plan" empty if no browser action is required. Prefer short, factual replies. `+r+a}]},generationConfig:{temperature:.3,responseMimeType:"application/json"}}},Y=t=>{if(!t)return null;const n=t.trim().replace(/```json|```/g,"").trim();try{return JSON.parse(n)}catch{try{const o=n.indexOf("{"),c=n.lastIndexOf("}");if(o!==-1&&c!==-1&&c>o)return JSON.parse(n.slice(o,c+1))}catch{}}return null},J=async(t,e)=>{var l,f,y,g,I;const{[w.GEMINI_KEY]:n}=await v([w.GEMINI_KEY]);if(!n)throw new Error("missing-gemini-key");const s=await C(),o=await P(s==null?void 0:s.id),c=W(e,t,p.getStatus(),s,o),i=await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${V}:generateContent?key=${encodeURIComponent(n)}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)});if(!i.ok){const A=await i.text();throw new Error(`gemini-error:${i.status}:${A||i.statusText}`)}const r=await i.json(),a=((I=(g=(y=(f=(l=r==null?void 0:r.candidates)==null?void 0:l[0])==null?void 0:f.content)==null?void 0:y.parts)==null?void 0:g[0])==null?void 0:I.text)??"",d=Y(a);return!d||typeof d.reply!="string"||!Array.isArray(d.plan)?{reply:a||"I was unable to create a plan.",plan:[]}:{reply:d.reply,plan:d.plan.filter(A=>A&&typeof A.type=="string")}},R=async(t,e)=>{var o;const n=[];let s=await C();for(let c=0;c<t.length;c+=1){const i=t[c];E("LLM_PROGRESS",{status:"running",index:c,step:i});try{const r=i!=null&&i.params&&typeof i.params=="object"?i.params:{};let a;if(i.type==="CALL_TOOL"){let d=r.tool||r.toolName||r.tool_name||r.toolCode||r.tool_code||r.name||i.tool||i.toolName||i.tool_name||i.toolCode||i.tool_code,l;if(!d){let u=null,m={};if(r!=null&&r.selector)(r==null?void 0:r.value)!==void 0?(u="extension_fill_selector",m={selector:r.selector,value:r.value}):(u="extension_click_selector",m={selector:r.selector});else if(r!=null&&r.url)u="extension_select_page",m={url:r.url};else if((r==null?void 0:r.pageId)!==void 0||(r==null?void 0:r.page_id)!==void 0){const _=(r==null?void 0:r.pageId)??(r==null?void 0:r.page_id);u=p.isConnected()?"select_page":"extension_select_page",m={pageId:_,page_id:_}}else r!=null&&r.code?(u="extension_evaluate_script",m={code:r.code}):r!=null&&r.text&&typeof r.text=="string"&&(u="extension_fill_selector",m={selector:r.selector??"input",value:r.text});if(u)E("LLM_WARNING",{message:"CALL_TOOL missing tool name — inferring tool",inferredTool:u,originalStep:i}),d=u,l=m;else throw new Error("call-tool-missing-name")}const f=i,y=r;l||(l=r.arguments||r.tool_params||r.toolParams||r.args||i.arguments||i.args||i.tool_params||i.toolParams||{}),!l||Object.keys(l).length===0?(f.url&&(l={...l,url:f.url}),y.url&&(l={...l,url:y.url}),f.selector&&(l={...l,selector:f.selector}),f.value&&(l={...l,value:f.value}),f.code&&(l={...l,code:f.code}),f.tool_params&&typeof f.tool_params=="object"&&(l={...l,...f.tool_params}),y.tool_params&&typeof y.tool_params=="object"&&(l={...l,...y.tool_params})):(f.url&&(l.url=f.url),y.url&&(l.url=y.url));try{E("LLM_DEBUG",{message:"Resolved CALL_TOOL",index:c,step:i,toolName:d,toolArgs:l})}catch{}console.debug("[MCP DEBUG] CALL_TOOL resolved",{index:c,toolName:d,toolArgs:l,step:i});const g=String(d||"").toLowerCase(),I=g.startsWith("extension_"),A=g.startsWith("pages_")||g==="new_page"||g==="navigate_page"||g==="list_pages"||g==="select_page",h=u=>l&&l[u]!==void 0?l[u]:i[u]??r[u];if(A)if(g==="new_page"){const u=h("url"),m=!!h("forceNew")||!!h("force_new");if(!u)throw E("LLM_WARNING",{message:"Blocked request to open a new page without URL.",index:c,step:i}),new Error("blocked-new-page-without-url");if(m){if(!p.isConnected())throw E("LLM_WARNING",{message:"Attempted force-new but MCP bridge not connected; blocked.",index:c,step:i}),new Error("blocked-new-page-force-new-bridge-off");a=await p.callTool("new_page",l)}else a=await T.handleAction({type:"NAVIGATE",url:u,tabId:e})}else if(g==="navigate_page"||g==="pages_navigate"||g==="pages_navigate_page"){const u=h("url");if(!u)throw new Error("navigate-missing-url");a=await T.handleAction({type:"NAVIGATE",url:u,tabId:e})}else if(g==="list_pages")a={content:[{type:"text",text:await P(s==null?void 0:s.id)??`# list_pages response
## Pages
0: ${(s==null?void 0:s.url)??"about:blank"} [selected]`}]};else if(g==="select_page"||g==="extension_select_page"){const u=h("url")??h("pageUrl")??h("page"),m=h("page_id")??h("pageId");let _=u;if(!_&&m!==void 0&&!p.isConnected()){const O=Number(m);if(!Number.isNaN(O))try{const M=await chrome.tabs.query({}),S=M==null?void 0:M[O];S!=null&&S.url&&(_=S.url)}catch{}}if(!_)if(m!==void 0)p.isConnected()?a=await p.callTool(d,l):a={success:!0,note:"no-url-select-skip"};else throw new Error("select-page-missing-url");!a&&_&&(N(s==null?void 0:s.url,_)?a={success:!0,note:"already-selected-tab"}:(a=await T.handleAction({type:"NAVIGATE",url:_,tabId:e}),a!=null&&a.success&&(s=await C())))}else{if(!p.isConnected())throw new Error("mcp-bridge-not-connected");a=await p.callTool(d,l)}else if(I)if(g.includes("click")&&h("selector"))a=await T.handleAction({type:"CLICK",selector:h("selector"),tabId:e});else if(g.includes("fill")&&h("selector"))a=await T.handleAction({type:"FILL",selector:h("selector"),value:h("value")??h("text")??h("v"),tabId:e});else if(g.includes("evaluate")&&h("code"))a=await T.handleAction({type:"EVALUATE_SCRIPT",code:h("code"),tabId:e});else if(g.includes("select_page")){const u=h("url")??h("pageUrl")??h("page");if(!u)throw new Error("select-page-missing-url");N(s==null?void 0:s.url,u)?a={success:!0,note:"already-selected-tab"}:(a=await T.handleAction({type:"NAVIGATE",url:u,tabId:e}),a!=null&&a.success&&(s=await C()))}else{if(!p.isConnected())throw new Error("mcp-bridge-not-connected");a=await p.callTool(d,l)}else{if(!p.isConnected())throw new Error("mcp-bridge-not-connected");a=await p.callTool(d,l)}if(a&&(a.isError||a.success===!1)){const m=(Array.isArray(a.content)?(o=a.content.find(_=>_&&typeof _.text=="string"))==null?void 0:o.text:void 0)||a.error||a.message||"CALL_TOOL failed";throw new Error(m)}}else a=await T.handleAction({...r,type:i.type,tabId:e});n.push({success:!0,result:a}),E("LLM_PROGRESS",{status:"completed",index:c,step:i,result:a}),i.type==="NAVIGATE"&&(a!=null&&a.success)&&(s=await C())}catch(r){n.push({success:!1,error:(r==null?void 0:r.message)??String(r)}),E("LLM_PROGRESS",{status:"failed",index:c,step:i,error:(r==null?void 0:r.message)??String(r)});break}}return n},B=async t=>{const{prompt:e,history:n=[],autoMode:s=!1,tabId:o}=t||{};if(!e||typeof e!="string")throw new Error("invalid-prompt");const c=typeof o=="number"?o:await U(),i=await J(e,n);E("LLM_PLAN",{plan:i.plan,reply:i.reply});let r;return s&&i.plan.length>0&&(r=await R(i.plan,c)),{success:!0,reply:i.reply,plan:i.plan,execution:r}},z=async t=>{const{plan:e=[],tabId:n}=t||{};if(!Array.isArray(e)||e.length===0)throw new Error("empty-plan");const s=typeof n=="number"?n:await U();return{success:!0,execution:await R(e,s)}},H=async t=>{const e={},n=[];if(typeof(t==null?void 0:t.geminiKey)=="string"&&(e[w.GEMINI_KEY]=t.geminiKey.trim()),typeof(t==null?void 0:t.autoMode)=="boolean"&&(e[w.AUTO_MODE]=t.autoMode),Object.prototype.hasOwnProperty.call(t??{},"mcpUrl")){const s=typeof(t==null?void 0:t.mcpUrl)=="string"?t.mcpUrl.trim():"";s?(e[w.MCP_URL]=s,p.setUrl(s)):(n.push(w.MCP_URL),p.setUrl(null))}return Object.keys(e).length&&await j(e),n.length&&await D(n),{success:!0}},Q=async()=>{const t=await v([w.GEMINI_KEY,w.AUTO_MODE,w.MCP_URL]);return{success:!0,geminiKey:(t==null?void 0:t[w.GEMINI_KEY])??null,autoMode:(t==null?void 0:t[w.AUTO_MODE])??!1,mcpUrl:(t==null?void 0:t[w.MCP_URL])??null,mcpStatus:p.getStatus()}},X=async t=>{const{tool:e,toolName:n,name:s,arguments:o,params:c}=t||{},i=e||n||s||(c==null?void 0:c.tool),r=o??(c==null?void 0:c.arguments)??(t==null?void 0:t.args)??{};if(!i)throw new Error("tool-required");return{success:!0,result:await p.callTool(i,r)}},Z=async()=>(p.reconnectNow(),{success:!0,status:p.getStatus()});chrome.runtime.onMessage.addListener((t,e,n)=>{const{type:s,payload:o}=t||{};if(!s)return;const c=i=>{i.then(r=>n(r)).catch(r=>n({success:!1,error:(r==null?void 0:r.message)??String(r)}))};switch(s){case"MCP_ACTION":return c(T.handleAction(o)),!0;case"LLM_REQUEST":return c(B(o)),!0;case"EXECUTE_PLAN":return c(z(o)),!0;case"SAVE_SETTINGS":return c(H(o)),!0;case"GET_SETTINGS":return c(Q()),!0;case"MCP_CALL_TOOL":return c(X(o)),!0;case"MCP_RECONNECT":return c(Z()),!0;default:n({success:!1,error:`unknown-message:${s}`});return}});p.onStatusChange(t=>{E("MCP_STATUS",{status:t})});p.onNotification(t=>{E("MCP_NOTIFICATION",t)});
